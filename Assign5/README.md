# Math 4610 Fundamentals of Computational Mathematics Assignment 5

**Routine Name:**           Routing

**Author:** Raul Ramirez

**Language:** C++, this code can be compiled with g++ compiler or gcc.

For example,

    g++ -std=c++11 aprox.cpp

will produce an executable **./a.out**, however, a better way to compile is to use `Make`, for example:

    make release

These will give you executables named **release**. You can then run the program by typing **./release**

**Description/Purpose:** This is more of a multi-directional program. This program will compute Vector Norms, Matrix Norms, Vector Errors, Matrix Addition, Matrix Subtraction, Dot Product of Two Vectors, Matrix and Vector Product, and Matrix and Matrix products. 

Vector Norms will generate a vector of size n. The user will specify the size of the vector. The vector will the generate n random doubles and perform the norms. For Vector Norm1, it will take the absolute value of all the elements in the vector, add them all up, and return the result of the addition. For Vector Norm2, it will take the absolute value of the sum of the squared values of n. And return the square root of the values. For Vector NormInf, it will return the largest value of the random doubles.

Matrix Norms will generate a matrix of size n x n. The user will specify the size of the Matrix, but the size is to remain symmetric for this purpose. The matrix is generated, again, with random doubles for each entry. Matrix Norm1 will add up all the columns, and will return the largest value of the columns. Matrix NormInf, will add up all the the rows, and return the largest value of the summation.

Vector Error will generate a vector of size n. The user will specify the size of the vector. The vector will generate n random doubles, and place them into two vectors x and y. x will then be subtracted by y, and the result will be stored in a vector n. They will then be passed into the same Vector Norms Class and return the results of Norm1,Norm2, and NormInf.

Matrix Addition will generate an n by n matrix. The user will specifiy the size of the matrix and the size will stay symmetric to ease the rules of matrix addition. However, this program can be modified to further obey the rules of matrix addition. The program will then generate two randomly filled matrices A and B, and will be added to a Matrix C. The program then will return the Matrix C.

Matrix Addition will generate an n by n matrix. The user will specifiy the size of the matrix and the size will stay symmetric to ease the rules of matrix addition. However, this program can be modified to further obey the rules of matrix addition. The program will then generate two randomly filled matrices A and B. A will be subtracted by B, and the results will be added to a Matrix C. The program then will return the Matrix C.

Dot Product will take two n sized vectors. The vectors are specified by the user, however, the vector sizes are the same. The vectors will then perform the dot product, and return the result of that dot product.

Matrix and Vector Product will take an n by n matrix. This time, the user can specify the dimensions of the matrix manually, however, the size of the vector x, is equal to the size of the row of the matrix, A. A will be generated by random doubles and filled in. The same rule applies to the vector x. The matrix will then multiply the vector in the fasion Ax=b, and the vector b will be returned.

Matrix and Matrix Product will take an n by n matrix. The user here must specify the dimensions of the matrix and must follow the rules of matrix multiplication. If the columns of the matrix, A, do not match the rows of the matrix, B, then the user must input correct dimensions and will be asked repeaditly to input the correct dimensions. The matrix A will then multiply the matrix B, and the result will be stored in a Matrix C.

**Input:** Depending on the program running, the user will be presented with the following menu:

```cpp
void printMenu()
{	
	std::cout << std::endl;
	std::cout << "Please enter a program to init: " << std::endl;
	std::cout << std::endl;
	std::cout << "  1 ------ Vector Norms" << std::endl;
	std::cout << "  2 ------ Matrix Norms" << std::endl;
	std::cout << "  3 ------ Vector Error" << std::endl;
	std::cout << "  4 ------ Matrix Addition" << std::endl;
	std::cout << "  5 ------ Matrix Subtraction" << std::endl;
	std::cout << "  6 ------ Dot Product" << std::endl;
	std::cout << "  7 ------ Matrix-Vector Product" << std::endl;
	std::cout << "  8 ------ Matrix-Matrix Product" << std::endl;
	std::cout << "  9 ------ Print this Menu Again" << std::endl;
	std::cout << "  10------ Kill the program" << std::endl;
	std::cout << std::endl;
}

```

The Menu is pretty straght forward.

**Output:** Depending on the program runned, you will get multiple outputs. Vector Norms returns doubles, Matrix Norms returns a double, Vector Error returns a double, Matrix Addition returns a matrix, Matrix Subtraction returns a matrix, Dot Product returns a double, Matrix-Vector Product returns a Vector, Matrix-Matrix Product returns a Matrix.

**Implementation/Code:** There is a lot of code to show, this is main.cpp:

```cpp
#include "vectorNorm.hpp"
#include "matrixNorm.hpp"
#include "vectorError.hpp"
#include "matrixAddition.hpp"
#include "matrixSubtraction.hpp"
#include "dotProduct.hpp"
#include "mxv.hpp"
#include "matrixProduct.hpp"

#include <iostream>

void printMenu()
{	
	std::cout << std::endl;
	std::cout << "Please enter a program to init: " << std::endl;
	std::cout << std::endl;
	std::cout << "  1 ------ Vector Norms" << std::endl;
	std::cout << "  2 ------ Matrix Norms" << std::endl;
	std::cout << "  3 ------ Vector Error" << std::endl;
	std::cout << "  4 ------ Matrix Addition" << std::endl;
	std::cout << "  5 ------ Matrix Subtraction" << std::endl;
	std::cout << "  6 ------ Dot Product" << std::endl;
	std::cout << "  7 ------ Matrix-Vector Product" << std::endl;
	std::cout << "  8 ------ Matrix-Matrix Product" << std::endl;
	std::cout << "  9 ------ Print this Menu Again" << std::endl;
	std::cout << "  10------ Kill the program" << std::endl;
	std::cout << std::endl;
}

int main()
{
	//============ Class Initialization =================
	VectorNorm a;
	MatrixNorm b;
	VectorError c;	
	MatrixAdd d;
	MatrixSub e;
	DotProduct f;
	MatrixVector g;	
	MatrixProduct h;	
	//============ User Input ===========================	

	int input = 0;	
	printMenu();
	std::cin >> input;

	while(input != 10)
	{
		if(input == 1)
		{
			a.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 2)
		{
			b.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 3)
		{
			c.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 4)
		{
			d.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 5)
		{
			e.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 6)
		{
			f.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 7)
		{
			g.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 8)
		{
			h.initProgram();
			printMenu();
			std::cin >> input;
		}
		else if(input == 9)
		{
			printMenu();
			std::cin >> input;
		}
		else
		{
			std::cout << "Sorry, that wasn't an option, try again: ";
			printMenu();
			std::cin >> input;
		}
	}

	return 0;
}

```

Again, main.cpp simply just initializes all the classes and then asks the user on which program they would like to run. The program can be closed down by typing 10.

This is the header file for vectorNorm.hpp:

```cpp
#ifndef VECTOR_NORM_HPP
#define VECTOR_NORM_HPP

#include <vector>

class VectorNorm
{

public:
	void initProgram();
	void printResults();
	
	double randomDouble();
		
	double vectorNorm1(std::vector<double> &n);
	double vectorNorm2(std::vector<double> &n);
	double vectorNormInf(std::vector<double> &n);

private:
	std::vector<double> n;
	double vectNorm1 = 0.0;	
	double vectNorm2 = 0.0;	
	double vectNormInf = 0.0;	

};


#endif

```

This is the cpp for VectorNorms:

```cpp
#include "vectorNorm.hpp"
#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cfenv>
#include <random>

void VectorNorm::initProgram()
{
	int size = 0;
	double ranNum = 0.0;

	std::cout << "Please enter a size of a vector of length n: ";
	std::cin >> size;

	for(int i = 0; i < size; ++i)
	{
		ranNum = randomDouble();
		n.push_back(ranNum);
	}


	printResults();
}

void VectorNorm::printResults()
{
	std::fesetround(FE_DOWNWARD);
	std::cout << "Vector Norm 1: " << std::fixed << std::setprecision(5) << vectorNorm1(n) << std::endl;
	std::cout << "Vector Norm 2: " << std::fixed << std::setprecision(5) << vectorNorm2(n) << std::endl;
	std::cout << "Vector Norm Inf: " << std::fixed << std::setprecision(5) << vectorNormInf(n) << std::endl;
	
	n.clear();
}

double VectorNorm::randomDouble()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-1000.0,1000.0);
	
	ranDouble = unif(generator);
	
	return ranDouble;	
}

double VectorNorm::vectorNorm1(std::vector<double>& n)
{
	for(auto &&e : n)
	{
		vectNorm1 += std::abs(e);	
	}

	return vectNorm1;
}


double VectorNorm::vectorNorm2(std::vector<double> &n)
{
	for(auto &&e : n)
	{
		vectNorm2 += std::pow(e,2);
	}
	
	vectNorm2 = std::abs(vectNorm2);
	
	return std::sqrt(vectNorm2);
}

double VectorNorm::vectorNormInf(std::vector<double> &n)
{
	std::vector<double> a;

	for(auto &&e : n)
	{
		a.push_back(std::abs(e));
	}

	vectNormInf = *std::max_element(a.begin(),a.end());

	return vectNormInf; 
}
```
This is the header file for Matrix Norms:

```cpp
#ifndef MATRIX_NORM_HPP
#define MATRIX_NORM_HPP

#include <vector>

class MatrixNorm
{
	
public:
	void initProgram();
	void printResults();

	double randNumber();

	double matrixNorm1(std::vector<std::vector<double>> &A);
	double matrixNormInf(std::vector<std::vector<double>> &B);
private:
	int size = 0;	
	std::vector<std::vector<double>> M;
	double mNorm1 = 0.0;
	double mNormInf = 0.0;

};

#endif
```
This is the cpp for Matrix Norms

```cpp
#include "matrixNorm.hpp"

#include <iostream>
#include <random>
#include <algorithm>
#include <iomanip>

void MatrixNorm::initProgram()
{
	double ranNum = 0.0;
	std::cout << "Please enter a size of an n by n Matrix: ";
	std::cin >> size;
	
	for(int i = 0; i < size; ++i)
	{
		std::vector<double> k;
		for(int j = 0; j < size; ++j)
		{
			ranNum = randNumber();
			k.emplace_back(ranNum);
		}
		M.emplace_back(k);
	}
	
	printResults();		

}


void MatrixNorm::printResults()
{
	std::cout << std::endl;
	std::cout << "The Matrix: " << std::endl;
	std::cout << std::endl;

	for(auto &&e: M)
	{
		for(auto && f: e)
		{
			std::cout << std::setw(10) << f << " ";
		}
		std::cout << std::endl;
	}

	std::cout << std::endl;
	std::cout << "Matrix Norm 1: " << matrixNorm1(M) << std::endl;
	std::cout << "Matrix Norm Inf: " << matrixNormInf(M) << std::endl;
	std::cout << std::endl;

	M.clear();
}

double MatrixNorm::randNumber()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-1000.0,1000.0);

	ranDouble = unif(generator);

	return ranDouble;
}

double MatrixNorm::matrixNorm1(std::vector<std::vector<double> > &A)
{
	std::vector<double> max;
	for(int i = 0; i < size; ++i)
	{
		double blah =0;
		for(int j = 0; j < size; ++j)
		{
			blah += std::abs(A[i][j]);
		}
		max.emplace_back(blah);
	}
	mNorm1 = *std::max_element(max.begin(),max.end());
	max.clear();	
	return mNorm1;
}

double MatrixNorm::matrixNormInf(std::vector<std::vector<double > > &B)
{
	std::vector<double> max;
	for(int i = 0; i < size; ++i)
	{
		double blah =0;
		for(int j = 0; j < size; ++j)
		{
			blah += std::abs(B[j][i]);
		}
		max.emplace_back(blah);
	}
	mNormInf = *std::max_element(max.begin(),max.end());
	max.clear();	
	return mNormInf;
}
```
This is the header file for Vector Errors:

```cpp
#ifndef VECTOR_ERROR_HPP
#define VECTOR_ERROR_HPP

#include "vectorNorm.hpp"

#include <vector>

class VectorError
{

public:
	void initProgram();
	void printResults();
	
	double randomDouble();
		
	double vectorError1(std::vector<double> &x, std::vector<double> &y);
	double vectorError2(std::vector<double> &x, std::vector<double> &y);
	double vectorErrorInf(std::vector<double> &x, std::vector<double> &y);

private:
	
	std::vector<double> x;
	std::vector<double> y;
	std::vector<double> n;

	double vectError1 = 0.0;	
	double vectError2 = 0.0;	
	double vectErrorInf = 0.0;	

};


#endif
```
This is the cpp for the Vector Error:

```cpp
#include "vectorError.hpp"

#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cfenv>
#include <random>

void VectorError::initProgram()
{
	int size = 0;
	double ranNum1 = 0.0;
	double ranNum2 = 0.0;

	std::cout << "Please enter a size of a vector of length n: ";
	std::cin >> size;

	for(int i = 0; i < size; ++i)
	{
		ranNum1 = randomDouble();
		ranNum2 = randomDouble();
		x.push_back(ranNum1);
		y.push_back(ranNum2);
	}

	printResults();
}

void VectorError::printResults()
{
	std::fesetround(FE_DOWNWARD);
	std::cout << "Vector Error 1: " << std::fixed << std::setprecision(5) << vectorError1(x,y) << std::endl;
	std::cout << "Vector Error 2: " << std::fixed << std::setprecision(5) << vectorError2(x,y) << std::endl;
	std::cout << "Vector Error Inf: " << std::fixed << std::setprecision(5) << vectorErrorInf(x,y) << std::endl;

	x.clear();
	y.clear();
	n.clear();
}

double VectorError::randomDouble()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-1000.0,1000.0);
	
	ranDouble = unif(generator);
	
	return ranDouble;	
}

double VectorError::vectorError1(std::vector<double>& x, std::vector<double> &y)
{
	VectorNorm a;
	std::set_difference(x.begin(),x.end(),y.begin(),y.end(),std::inserter(n,n.begin()));

	vectError1 = a.vectorNorm1(n);	
	return vectError1;
}


double VectorError::vectorError2(std::vector<double> &x, std::vector<double> &y)
{
	VectorNorm a;
	std::set_difference(x.begin(),x.end(),y.begin(),y.end(),std::inserter(n,n.begin()));

	vectError2 = a.vectorNorm2(n);	
	return vectError2;
}

double VectorError::vectorErrorInf(std::vector<double> &x, std::vector<double> &y)
{
	VectorNorm a;
	std::set_difference(x.begin(),x.end(),y.begin(),y.end(),std::inserter(n,n.begin()));
	
	vectErrorInf = a.vectorNormInf(n);
	
	return vectErrorInf;
}
```
This is the header for Matrix Addition:

```cpp
#ifndef MATRIX_ADDITION_HPP
#define MATRIX_ADDITION_HPP

#include <vector>

class MatrixAdd
{
	
public:
	void initProgram();
	void printResults();

	double randNumber();

	std::vector<std::vector<double> > matrixAdd(std::vector<std::vector<double>> &A,std::vector<std::vector<double>> &B);

private:
	int size = 0;	
	std::vector<std::vector<double>> A;
	std::vector<std::vector<double>> B;
	std::vector<std::vector<double>> C;
};

#endif

```
This is the cpp for Matrix Addition:

```cpp
#include "matrixAddition.hpp"

#include <iostream>
#include <random>
#include <algorithm>
#include <iomanip>

void MatrixAdd::initProgram()
{
	double ranNum1 = 0.0;
	double ranNum2 = 0.0;

	std::cout << "Please enter a size of an n by n Matrix: ";
	std::cin >> size;
	
	for(int i = 0; i < size; ++i)
	{
		std::vector<double> k;
		std::vector<double> l;
		for(int j = 0; j < size; ++j)
		{
			ranNum1 = randNumber();
			ranNum2 = randNumber();
			k.emplace_back(ranNum1);
			l.emplace_back(ranNum2);
		}
		A.emplace_back(k);
		B.emplace_back(l);
	}
	
	matrixAdd(A,B);
			
	printResults();		

}


void MatrixAdd::printResults()
{
	std::cout << std::endl;
	std::cout << "The Matrix: " << std::endl;
	std::cout << std::endl;

	for(auto &&a: A)
	{
		for(auto && b: a)
		{
			std::cout << std::setw(10) << b << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "+" << std::endl;
	for(auto &&c: B)
	{
		for(auto && d: c)
		{
			std::cout << std::setw(10) << d << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "=" << std::endl;
	for(auto &&e: C)
	{
		for(auto && f: e)
		{
			std::cout << std::setw(10) << f << " ";
		}
		std::cout << std::endl;
	}

	std::cout << std::endl;

	A.clear();
	B.clear();
	C.clear();
}

double MatrixAdd::randNumber()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-1000.0,1000.0);

	ranDouble = unif(generator);

	return ranDouble;
}

std::vector<std::vector<double> > MatrixAdd::matrixAdd(std::vector<std::vector<double> > &A,std::vector<std::vector<double> > &B)
{
	std::vector<std::vector<double> > temp(size, std::vector<double>(size));
	for(int i = 0; i < size; ++i)
	{
		for(int j = 0; j < size; ++j)
		{
			temp[i][j] = A[i][j] + B[i][j];
		}
	}
	C = temp;
	temp.clear();	
	return C;
}

```
This is the header file for Matrix Subtraction:

```cpp
#ifndef MATRIX_SUBTRACTION_HPP
#define MATRIX_SUBTRACTION_HPP

#include <vector>

class MatrixSub
{
	
public:
	void initProgram();
	void printResults();

	double randNumber();

	std::vector<std::vector<double> > matrixSub(std::vector<std::vector<double>> &A,std::vector<std::vector<double>> &B);

private:
	int size = 0;	
	std::vector<std::vector<double>> A;
	std::vector<std::vector<double>> B;
	std::vector<std::vector<double>> C;
};

#endif
```
This is the cpp for Matrix Subtraction:

```cpp
#include "matrixSubtraction.hpp"

#include <iostream>
#include <random>
#include <algorithm>
#include <iomanip>

void MatrixSub::initProgram()
{
	double ranNum1 = 0.0;
	double ranNum2 = 0.0;

	std::cout << "Please enter a size of an n by n Matrix: ";
	std::cin >> size;
	
	for(int i = 0; i < size; ++i)
	{
		std::vector<double> k;
		std::vector<double> l;
		for(int j = 0; j < size; ++j)
		{
			ranNum1 = randNumber();
			ranNum2 = randNumber();
			k.emplace_back(ranNum1);
			l.emplace_back(ranNum2);
		}
		A.emplace_back(k);
		B.emplace_back(l);
	}
	
	matrixSub(A,B);
			
	printResults();		

}


void MatrixSub::printResults()
{
	std::cout << std::endl;
	std::cout << "The Matrix: " << std::endl;
	std::cout << std::endl;

	for(auto &&a: A)
	{
		for(auto && b: a)
		{
			std::cout << std::setw(10) << b << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "-" << std::endl;
	for(auto &&c: B)
	{
		for(auto && d: c)
		{
			std::cout << std::setw(10) << d << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "=" << std::endl;
	for(auto &&e: C)
	{
		for(auto && f: e)
		{
			std::cout << std::setw(10) << f << " ";
		}
		std::cout << std::endl;
	}

	std::cout << std::endl;

	A.clear();
	B.clear();
	C.clear();
}

double MatrixSub::randNumber()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-1000.0,1000.0);

	ranDouble = unif(generator);

	return ranDouble;
}

std::vector<std::vector<double> > MatrixSub::matrixSub(std::vector<std::vector<double> > &A,std::vector<std::vector<double> > &B)
{
	std::vector<std::vector<double> > temp(size, std::vector<double>(size));
	for(int i = 0; i < size; ++i)
	{
		for(int j = 0; j < size; ++j)
		{
			temp[i][j] = A[i][j] - B[i][j];
		}
	}
	C = temp;
	temp.clear();	
	return C;
}
```

This is the header file for Dot Product: 

```cpp
#ifndef DOT_PRODUCT_HPP
#define DOT_PRODUCT_HPP

#include <vector>

class DotProduct
{

public:

	void initProgram();
	void printResults();
	
	double dotProd(std::vector<double> &x, std::vector<double> &y);	
	double randomDouble(); 

private:
	
	std::vector<double> x;
	std::vector<double> y;

	double result = 0.0;

};

#endif

```
This is the cpp for Dot Product:

```cpp
#include "dotProduct.hpp"

#include <cmath>
#include <algorithm>
#include <iostream>
#include <iomanip>
#include <cfenv>
#include <random>

void DotProduct::initProgram()
{
	int size = 0;
	double ranNum1 = 0.0;
	double ranNum2 = 0.0;

	std::cout << "Please enter a size of a vector of length n: ";
	std::cin >> size;

	for(int i = 0; i < size; ++i)
	{
		ranNum1 = randomDouble();
		ranNum2 = randomDouble();
		x.push_back(ranNum1);
		y.push_back(ranNum2);
	}
	
	dotProd(x,y);	
	printResults();
}

void DotProduct::printResults()
{
	std::cout << "[ ";
	for(auto &&a : x)
	{
		std::cout << std::fixed << std::setprecision(5) << a << " ";
	}
	std::cout << "] * [ ";
	for(auto &&b : y)
	{
		std::cout << std::fixed << std::setprecision(5) << b << " ";
	}
	std::cout << "] = "; 
	std::cout << result << std::endl;

	x.clear();
	y.clear();	
}

double DotProduct::dotProd(std::vector<double> &x, std::vector<double> &y)
{
	
	result = std::inner_product(x.begin(),x.end(),y.begin(),0.0);
	return result;
}

double DotProduct::randomDouble()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-10.0,10.0);
	
	ranDouble = unif(generator);
	
	return ranDouble;	
}
```
This is the header file for Matrix-Vector Multiplication:

```cpp
#ifndef MATRIX_VECTOR_HPP
#define MATRIX_VECTOR_HPP

#include <vector>

class MatrixVector
{
	
public:
	void initProgram();
	void printResults();

	double randNumber();

	std::vector<double> matrixVector(std::vector<std::vector<double>> &A,std::vector<double> &x);

private:
	int rowA = 0;	
	int colA = 0;	
		
	std::vector<std::vector<double>> A;
	std::vector<double> x;
	std::vector<double> b;
};

#endif
```
This is the cpp file for Matrix-Vector Multiplication:

```cpp
#include "mxv.hpp"

#include <iostream>
#include <random>
#include <algorithm>
#include <iomanip>

void MatrixVector::initProgram()
{
	double ranNum1 = 0.0;
	double ranNum2 = 0.0;

	std::cout << "Please enter rows of Matrix A: ";
	std::cin >> rowA;
	std::cout << "Please enter columns of Matrix A: ";
	std::cin >> colA;
	
	for(int i = 0; i < rowA; ++i)
	{
		std::vector<double> k;
		for(int j = 0; j < colA; ++j)
		{
			ranNum1 = randNumber();
			k.emplace_back(ranNum1);
		}
		A.emplace_back(k);
	}
	
	for(int i = 0; i < rowA; ++i)
	{
		ranNum2 = randNumber();
		x.emplace_back(ranNum2);
	}
	
	matrixVector(A,x);
			
	printResults();		

}


void MatrixVector::printResults()
{
	std::cout << std::endl;
	std::cout << "The Matrix: " << std::endl;
	std::cout << std::endl;

	for(auto &&a: A)
	{
		for(auto && b: a)
		{
			std::cout << std::setw(10) << b << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "*" << std::endl;
	for(auto &&c: x)
	{
		std::cout << std::setw(10) << c << " ";
	}
	std::cout << std::endl;
	std::cout << "=" << std::endl;
	for(auto &&e: b)
	{
		std::cout << std::setw(10) << e << " ";
	}
	std::cout << std::endl;

	A.clear();
	x.clear();
	b.clear();
}

double MatrixVector::randNumber()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-10.0,10.0);

	ranDouble = unif(generator);

	return ranDouble;
}

std::vector<double> MatrixVector::matrixVector(std::vector<std::vector<double> > &A, std::vector<double> &x)
{
	std::vector<double> temp(rowA);

	for(int i = 0; i < rowA; ++i)
	{
		for(int j = 0; j < rowA; ++j)
		{
			temp[i] += (A[i][j] * x[j]);
		}
	}
	
	b = temp;	
	temp.clear();
	return b;
}
```
This is the header file for Matrix-Matrix Multiiplication:

```cpp
#ifndef MATRIX_PRODUCT_HPP
#define MATRIX_PRODUCT_HPP

#include <vector>

class MatrixProduct
{
	
public:
	void initProgram();
	void printResults();

	double randNumber();

	std::vector<std::vector<double> > matrixProd(std::vector<std::vector<double>> &A,std::vector<std::vector<double>> &B);

private:
	int rowA = 0;	
	int rowB = 0;	
	int colA = 0;
	int colB = 0;
		
	std::vector<std::vector<double>> A;
	std::vector<std::vector<double>> B;
	std::vector<std::vector<double>> C;
};

#endif
```
This is the cpp files for Matrix-Matrix Multiplication:

```cpp
#include "matrixProduct.hpp"

#include <iostream>
#include <random>
#include <algorithm>
#include <iomanip>

void MatrixProduct::initProgram()
{
	double ranNum1 = 0.0;
	double ranNum2 = 0.0;

	std::cout << "Please enter rows of Matrix A: ";
	std::cin >> rowA;
	std::cout << "Please enter columns of Matrix A: ";
	std::cin >> colA;
	std::cout << "Please enter rows of Matrix B: ";
	std::cin >> rowB;
	std::cout << "Please enter columns of Matrix B: ";
	std::cin >> colB;

	if(colA != rowB)
	{
		std::cout << "Not a computable Matrix, please enter rows and columns again!" << std::endl;
		initProgram();
	}



	for(int i = 0; i < rowA; ++i)
	{
		std::vector<double> k;
		for(int j = 0; j < colA; ++j)
		{
			ranNum1 = randNumber();
			k.emplace_back(ranNum1);
		}
		A.emplace_back(k);
	}
	
	for(int i = 0; i < rowB; ++i)
	{
		std::vector<double> l;
		for(int j = 0; j < colB; ++j)
		{
			ranNum2 = randNumber();
			l.emplace_back(ranNum2);
		}
		B.emplace_back(l);
	}
	matrixProd(A,B);
			
	printResults();		

}


void MatrixProduct::printResults()
{
	std::cout << std::endl;
	std::cout << "The Matrix: " << std::endl;
	std::cout << std::endl;

	for(auto &&a: A)
	{
		for(auto && b: a)
		{
			std::cout << std::setw(10) << b << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "*" << std::endl;
	for(auto &&c: B)
	{
		for(auto && d: c)
		{
			std::cout << std::setw(10) << d << " ";
		}
		std::cout << std::endl;
	}
	std::cout << "=" << std::endl;
	for(auto &&e: C)
	{
		for(auto && f: e)
		{
			std::cout << std::setw(10) << f << " ";
		}
		std::cout << std::endl;
	}

	std::cout << std::endl;

	A.clear();
	B.clear();
	C.clear();
}

double MatrixProduct::randNumber()
{
	double ranDouble = 0.0;
	std::random_device rd;
	std::default_random_engine generator(rd());
	std::uniform_real_distribution<double> unif(-10.0,10.0);

	ranDouble = unif(generator);

	return ranDouble;
}

std::vector<std::vector<double> > MatrixProduct::matrixProd(std::vector<std::vector<double> > &A,std::vector<std::vector<double> > &B)
{
	std::vector<std::vector<double> > temp(rowA, std::vector<double>(colB));
	for(int i = 0; i < rowA; ++i)
	{
		for(int j = 0; j < colB; ++j)
		{
			for(int k = 0; k < rowB; ++k)
			{
				temp[i][j] += A[i][k] * B[k][j];
			}
		}
	}
	C = temp;
	temp.clear();	
	return C;
}

```

This code has been explained in the description in great detail.
**Last Modified:** October/2017
